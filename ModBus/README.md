# FreeRTPS ModBus RTU
Библиотека ModBus RTU с RS485 на физическом уровне для STM32F1xx с использованием FreeRTOS.

# Инициализация
1.  Добавить папку ModBus в папку проекта
2.  Добавить путь к папке в параметрах проекта ("C/C++ General"->"Paths and Symbols"->"Includes" для STM32CubelIDE)
3.  Инициализировать в CUBE TIMx (включит прерывание по переполнению), USARTx(включит прерывание по приему/отправке),
    выход GPIO (DE). При необходимости IWDG. Подключить FreeRTOS, если еще не подключен.
4.  Подключить к "main.c" хэдер "mb.h"
5.  Объявить и инициализировать структуру "MBinit" в секции "USER CODE BEGIN Init":

static modbusStruct MBinit;
MBinit.uart   	= &huart1;
MBinit.tim    	= &htim2;
#if( IWDG_ON )
    MBinit.iwdg   	= &hiwdg;
#endif
MBinit.adrType	= ADR_REGISTER;
MBinit.adr    	= &netAdr;
MBinit.DEport 	= DE_GPIO_Port;
MBinit.DEpin  	= DE_Pin;
MBinit.bank   	= FLASH_BANK_1;
MBinit.page   	= 63U;

Где:
    huart1          - сгенерированная CUBE структура USARTx
    htim2           - сгенерированная CUBE структура TIMx
    hiwdg           - сгенерированная CUBE структура IWDG
    adrType         - флаг источника сетевого адреса (ADR_REGISTER - адрес из памяти, ADR_POINTER - адрес по указателю adr)
    netAdr          - указатель на сетевой адресс
    DE_GPIO_Port    - сгенерированный CUBE порт выхода DE
    DE_Pin          - сгенерированный CUBE пин выхода DE
    FLASH_BANK_1    - номер банка flash памяти в котором выделяеться страница для хранения регистров ModBus
    63U             - номер страницы памяти во flash для хранения регистров ModBus
    
6.  В секции "USER CODE BEGIN 2" разместить вызов функции "eMBInit( MBinit )" -Инициализация аппаратной части.
    Функция должна вернуть "EBInit_OK"
7.  В секции "USER CODE BEGIN RTOS_QUEUES" разместить вызов функции "vMBQueueInit()" - Инициализация стрима и эвентов.
8.  В секции "USER CODE BEGIN RTOS_THREADS" разместить вызов функции "vMBTaskInit()" - Инициализация таска пула.
9.  Открыть файл "stm32f1xx_hal_it.c"
10. В обработчике прерывания таймера в секции "USER CODE BEGIN TIMx_IRQn 1" разместить вызов функции "vMBtimHandler()"
11. В обработчике прерывания USART в секции "USER CODE BEGIN USARTx_IRQn 0" разместить вызов функции "vMBuartHandler()"
12. В случаее использования IWDG в "mbport.h" установить IWDG_ON как 1U
13. В "mbregister.h" выбрать необходимое кол-во ROM и RAM регистров и их изначальные значения в секции "USER MEMORY SIZE"

# Запись/чтение
Для доступа к пользовательским регистрам стоит использовать следующие функции:

USHORT usMBReadUserRegister( USHORT adr ) - чтение регистра по адресу
void vMBWriteUserRegister( USHORT adr, UCHAR *data, USHORT count ) - запись массива данных в регистры начиная с адреса adr
void vMBWriteShortToUserRegister( USHORT adr, USHORT data, eMBRAMwrType wr ) - запись данных регистр по адресу

wr - флаг записи во флешь. Если адрес попал в область RAM, то в зависимости от значения флага:
ROM_WR      - будет произведена запись в буфер и во флэшь
RAM_NON_WR  - будет произведена запись в буфер, но не произведена запись во флэшь. Для последующей записи данных во
              флэшь стоит выхвать функцию vMBWriteROMRegister(). Запись во флэшь находиться в крисической секции и
              может уменьшить детерминированность системы в целом. Таким образом можно выбирать время записи во флешь данных,
              в моменты времени, когда задача не требует повышенной детерминированности системы.

# События
При помощи функции void vMBEventGet( EventBits_t* uxBits ) можно получать данные об изменении значений регистров. Размер массива битовых полей 
будет равен OS_MB_EVENT_ARRAY_SIZE, при этом сам размер поля будет равен OS_MB_EVENT_GROUP_SIZE (В случае STM32F1xx он равен 24). Номер бита будет
соотвествовать адресу регистра. Для использвания подключить: "FreeRTOS.h" и "event_groups.h".

# Не регламентированные команды
Команда №66 позволяет менять скорость USART, бит контроля и сетевой адрес. Сообщение будет иметь вид в HEX:

|  01 |  42 | 00 00 |  09 |
| ADR | CMD |  SUB  | DAT |

ADR - сетевой адресс устройства
CMD - номер команда
SUB - сабфункция
DAT - данные

сабфункции | Данные

00 00 - изменение скорости USART
                00 - 1200
                01 - 2400
                02 - 4800
                03 - 9600
                04 - 14400
                05 - 19200
                06 - 38400
                07 - 56000
                08 - 57600
                09 - 115200
                0A - 128000
                0B - 256000
00 01 - изменение контрольного бита
                00 - 8 бит сообщение, 2 стоп бита, нет контроля четности
                01 - 9 бит сообщение, 1 стоп бит, контроль четный
                02 - 9 бит сообщение, 1 стоп бит, контроль нечетный
00 02 - изменение сетевого адреса устройства